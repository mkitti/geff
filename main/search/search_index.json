{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to geff!","text":"<p>geff is a specification for a file format for exchanging spatial graph data. It is not intended to be mutable, editable, chunked, or optimized for use in an application setting.</p> <p>geff is the specification of the file format, but the library also includes implementations for writing from and reading to a networkx graph, a common Python in-memory graph data structure. The library uses semantic versioning, where changes to the specification bump the major or minor versions, and bugfixes for the example implementation bumps the patch version.</p> <p>Learn more in the documentation or check out the source code.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install geff\n</code></pre>"},{"location":"api/","title":"API Docs","text":""},{"location":"api/#networkx-backend","title":"Networkx Backend","text":""},{"location":"api/#geff.read_nx","title":"geff.read_nx","text":"<pre><code>read_nx(\n    store: StoreLike,\n    validate: bool = True,\n    node_props: list[str] | None = None,\n    edge_props: list[str] | None = None,\n) -&gt; tuple[nx.Graph, GeffMetadata]\n</code></pre> <p>Read a geff file into a networkx graph. Metadata properties will be stored in the graph properties, accessed via <code>G.graph[key]</code> where G is a networkx graph.</p> <p>Parameters:</p> Name Type Description Default <code>store</code> <code>str | Path | zarr store</code> <p>The path/str to the geff zarr, or the store itself. Opens in append mode, so will only overwrite geff-controlled groups.</p> required <code>validate</code> <code>bool</code> <p>Flag indicating whether to perform validation on the geff file before loading into memory. If set to False and there are format issues, will likely fail with a cryptic error. Defaults to True.</p> <code>True</code> <code>node_props</code> <code>list of str</code> <p>The names of the node properties to load, if None all properties will be loaded, defaults to None.</p> <code>None</code> <code>edge_props</code> <code>list of str</code> <p>The names of the edge properties to load, if None all properties will be loaded, defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[Graph, GeffMetadata]</code> <p>A networkx graph containing the graph that was stored in the geff file format</p>"},{"location":"api/#geff.write_nx","title":"geff.write_nx","text":"<pre><code>write_nx(\n    graph: Graph,\n    store: StoreLike,\n    metadata: GeffMetadata | None = None,\n    axis_names: list[str] | None = None,\n    axis_units: list[str | None] | None = None,\n    axis_types: list[str | None] | None = None,\n    zarr_format: Literal[2, 3] = 2,\n)\n</code></pre> <p>Write a networkx graph to the geff file format</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>A networkx graph</p> required <code>store</code> <code>str | Path | zarr store</code> <p>The path/str to the output zarr, or the store itself. Opens in append mode, so will only overwrite geff-controlled groups.</p> required <code>metadata</code> <code>GeffMetadata</code> <p>The original metadata of the graph. Defaults to None. If provided, will override the graph properties.</p> <code>None</code> <code>axis_names</code> <code>Optional[list[str]]</code> <p>The names of the spatial dims represented in position property. Defaults to None. Will override both value in graph properties and metadata if provided.</p> <code>None</code> <code>axis_units</code> <code>Optional[list[str]]</code> <p>The units of the spatial dims represented in position property. Defaults to None. Will override value both value in graph properties and metadata if provided.</p> <code>None</code> <code>axis_types</code> <code>Optional[list[str]]</code> <p>The types of the spatial dims represented in position property. Usually one of \"time\", \"space\", or \"channel\". Defaults to None. Will override both value in graph properties and metadata if provided.</p> <code>None</code> <code>zarr_format</code> <code>Literal[2, 3]</code> <p>The version of zarr to write. Defaults to 2.</p> <code>2</code>"},{"location":"api/#utilities","title":"Utilities","text":""},{"location":"api/#geff.validate","title":"geff.validate","text":"<pre><code>validate(store: StoreLike)\n</code></pre> <p>Check that the structure of the zarr conforms to geff specification</p> <p>Parameters:</p> Name Type Description Default <code>store</code> <code>str | Path | zarr store</code> <p>Check the geff zarr, either str/Path/store</p> required <p>Raises:</p> Type Description <code>AssertionError</code> <p>If geff specs are violated</p> <code>ValueError</code> <p>If store is not a valid zarr store or path doesn't exist</p>"},{"location":"api/#metadata","title":"Metadata","text":""},{"location":"api/#geff.GeffMetadata","title":"geff.GeffMetadata","text":"<p>               Bases: <code>BaseModel</code></p> <p>Geff metadata schema to validate the attributes json file in a geff zarr</p>"},{"location":"api/#geff.GeffMetadata.read","title":"read  <code>classmethod</code>","text":"<pre><code>read(store: StoreLike) -&gt; GeffMetadata\n</code></pre> <p>Helper function to read GeffMetadata from a zarr geff group.</p> <p>Parameters:</p> Name Type Description Default <code>store</code> <code>zarr store | Path | str</code> <p>The geff store to read the metadata from</p> required <p>Returns:</p> Name Type Description <code>GeffMetadata</code> <code>GeffMetadata</code> <p>The GeffMetadata object</p>"},{"location":"api/#geff.GeffMetadata.write","title":"write","text":"<pre><code>write(store: StoreLike)\n</code></pre> <p>Helper function to write GeffMetadata into the group of a zarr geff store. Maintains consistency by preserving ignored attributes with their original values.</p> <p>Parameters:</p> Name Type Description Default <code>store</code> <code>zarr store | Path | str</code> <p>The geff store to write the metadata to</p> required"},{"location":"api/#geff.metadata_schema.Axis","title":"geff.metadata_schema.Axis","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/#geff.metadata_schema.axes_from_lists","title":"geff.metadata_schema.axes_from_lists","text":"<pre><code>axes_from_lists(\n    axis_names: Sequence[str] | None = None,\n    axis_units: Sequence[str | None] | None = None,\n    axis_types: Sequence[str | None] | None = None,\n    roi_min: Sequence[float | None] | None = None,\n    roi_max: Sequence[float | None] | None = None,\n) -&gt; list[Axis]\n</code></pre> <p>Create a list of Axes objects from lists of axis names, units, types, mins, and maxes. If axis_names is None, there are no spatial axes and the list will be empty. Nones for all other arguments will omit them from the axes.</p> <p>All provided arguments must have the same length. If an argument should not be specified for a single property, use None.</p> <p>Parameters:</p> Name Type Description Default <code>axis_names</code> <code>list[str] | None</code> <p>Names of properties for spatiotemporal axes. Defaults to None.</p> <code>None</code> <code>axis_units</code> <code>list[str | None] | None</code> <p>Units corresponding to named properties. Defaults to None.</p> <code>None</code> <code>axis_types</code> <code>list[str | None] | None</code> <p>Axis type for each property. Choose from \"space\", \"time\", \"channel\". Defaults to None.</p> <code>None</code> <code>roi_min</code> <code>list[float | None] | None</code> <p>Minimum value for each property. Defaults to None.</p> <code>None</code> <code>roi_max</code> <code>list[float | None] | None</code> <p>Maximum value for each property. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Axis]</code> <p>list[Axis]:</p>"},{"location":"api/#units","title":"Units","text":""},{"location":"api/#geff.valid_values.validate_axis_type","title":"geff.valid_values.validate_axis_type","text":"<pre><code>validate_axis_type(axis_type: str) -&gt; bool\n</code></pre> <p>Validate axis type against standard list</p> <p>Parameters:</p> Name Type Description Default <code>axis_type</code> <code>str</code> <p>Axis type to check</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>False if the axis is not in valid types</p>"},{"location":"api/#geff.valid_values.VALID_AXIS_TYPES","title":"geff.valid_values.VALID_AXIS_TYPES  <code>module-attribute</code>","text":"<pre><code>VALID_AXIS_TYPES = ['space', 'time', 'channel']\n</code></pre>"},{"location":"api/#geff.valid_values.validate_space_unit","title":"geff.valid_values.validate_space_unit","text":"<pre><code>validate_space_unit(unit_name: str) -&gt; bool\n</code></pre> <p>Checks space unit against ome-zarr supported units</p> <p>Parameters:</p> Name Type Description Default <code>unit_name</code> <code>str</code> <p>Unit name to check</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if a space unit is a KNOWN valid unit.</p> <code>bool</code> <p>False if the unit is not known. The unit may be valid.</p>"},{"location":"api/#geff.valid_values.VALID_SPACE_UNITS","title":"geff.valid_values.VALID_SPACE_UNITS  <code>module-attribute</code>","text":"<pre><code>VALID_SPACE_UNITS = [\n    None,\n    \"angstrom\",\n    \"attometer\",\n    \"centimeter\",\n    \"decimeter\",\n    \"exameter\",\n    \"femtometer\",\n    \"foot\",\n    \"gigameter\",\n    \"hectometer\",\n    \"inch\",\n    \"kilometer\",\n    \"megameter\",\n    \"meter\",\n    \"micrometer\",\n    \"mile\",\n    \"millimeter\",\n    \"nanometer\",\n    \"parsec\",\n    \"petameter\",\n    \"picometer\",\n    \"terameter\",\n    \"yard\",\n    \"yoctometer\",\n    \"yottameter\",\n    \"zeptometer\",\n    \"zettameter\",\n]\n</code></pre>"},{"location":"api/#geff.valid_values.validate_time_unit","title":"geff.valid_values.validate_time_unit","text":"<pre><code>validate_time_unit(unit_name: str) -&gt; bool\n</code></pre> <p>Check time unit against ome-zarr supported units</p> <p>Parameters:</p> Name Type Description Default <code>unit_name</code> <code>str</code> <p>Unit name to check</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if a time unit is a KNOWN valid unit.</p> <code>bool</code> <p>False if the unit is not known. The unit may be valid.</p>"},{"location":"api/#geff.valid_values.VALID_TIME_UNITS","title":"geff.valid_values.VALID_TIME_UNITS  <code>module-attribute</code>","text":"<pre><code>VALID_TIME_UNITS = [\n    None,\n    \"attosecond\",\n    \"centisecond\",\n    \"day\",\n    \"decisecond\",\n    \"exasecond\",\n    \"femtosecond\",\n    \"gigasecond\",\n    \"hectosecond\",\n    \"hour\",\n    \"kilosecond\",\n    \"megasecond\",\n    \"microsecond\",\n    \"millisecond\",\n    \"minute\",\n    \"nanosecond\",\n    \"petasecond\",\n    \"picosecond\",\n    \"second\",\n    \"terasecond\",\n    \"yoctosecond\",\n    \"yottasecond\",\n    \"zeptosecond\",\n    \"zettasecond\",\n]\n</code></pre>"},{"location":"api/#writing-helpers","title":"Writing Helpers","text":""},{"location":"api/#geff.write_arrays.write_arrays","title":"geff.write_arrays.write_arrays","text":"<pre><code>write_arrays(\n    geff_store: StoreLike,\n    node_ids: ndarray,\n    node_props: dict[str, tuple[ndarray, ndarray | None]]\n    | None,\n    edge_ids: ndarray,\n    edge_props: dict[str, tuple[ndarray, ndarray | None]]\n    | None,\n    metadata: GeffMetadata,\n    node_props_unsquish: dict[str, list[str]] | None = None,\n    edge_props_unsquish: dict[str, list[str]] | None = None,\n    zarr_format: Literal[2, 3] = 2,\n)\n</code></pre> <p>Write a geff file from already constructed arrays of node and edge ids and props</p> <p>Currently does not do any validation that the arrays are valid, but could be added as an optional flag.</p> <p>Parameters:</p> Name Type Description Default <code>geff_store</code> <code>str | Path | zarr store</code> <p>The path/str to the geff zarr, or the store itself. Opens in append mode, so will only overwrite geff-controlled groups.</p> required <code>node_ids</code> <code>ndarray</code> <p>An array containing the node ids. Must have same dtype as edge_ids.</p> required <code>node_props</code> <code>dict[str, tuple[ndarray, ndarray | None]] | None</code> <p>A dictionary from node property names to (values, missing) arrays, which should have same length as node_ids.</p> required <code>edge_ids</code> <code>ndarray</code> <p>An array containing the edge ids. Must have same dtype as node_ids.</p> required <code>edge_props</code> <code>dict[str, tuple[ndarray, ndarray | None]] | None</code> <p>A dictionary from edge property names to (values, missing) arrays, which should have same length as edge_ids.</p> required <code>metadata</code> <code>GeffMetadata</code> <p>The metadata of the graph.</p> required <code>zarr_format</code> <code>Literal[2, 3]</code> <p>The zarr specification to use when writing the zarr. Defaults to 2.</p> <code>2</code> <code>node_props_unsquish</code> <code>dict[str, list[str]] | None</code> <p>a dictionary indicication how to \"unsquish\" a property into individual scalars (e.g.: <code>{\"pos\": [\"z\", \"y\", \"x\"]}</code> will store the position property as three individual properties called \"z\", \"y\", and \"x\".</p> <code>None</code> <code>edge_props_unsquish</code> <code>dict[str, list[str]] | None</code> <p>a dictionary indicication how to \"unsquish\" a property into individual scalars (e.g.: <code>{\"pos\": [\"z\", \"y\", \"x\"]}</code> will store the position property as three individual properties called \"z\", \"y\", and \"x\".</p> <code>None</code>"},{"location":"command-line-tools/","title":"Command line tools","text":""},{"location":"command-line-tools/#geff","title":"geff","text":"<p>GEFF Command Line Interface</p> <p>Usage:</p> <pre><code> [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or\n                        customize the installation.\n</code></pre>"},{"location":"command-line-tools/#convert-ctc","title":"convert-ctc","text":"<p>Convert a CTC data directory to a GEFF file.</p> <p>Usage:</p> <pre><code> convert-ctc [OPTIONS] CTC_PATH GEFF_PATH\n</code></pre> <p>Options:</p> <pre><code>  CTC_PATH                      The path to the directory containing ctc\n                                tracks (man_track.txt or res_track.txt), e.g.\n                                data/01_GT/TRA or data/01_RES  \\[required]\n  GEFF_PATH                     Path to save the output geff, including the\n                                geff directory name (eg.\n                                ~/folder/folder/data.zarr/tracks.geff)\n                                \\[required]\n  --segm-path PATH              The path to export the segmentation file, if\n                                not provided, it won't be exported.\n  --input-image-dir PATH        The path to the input image directory. If not\n                                provided, it won't be exported.\n  --output-image-path PATH      The path to export the image file, if not\n                                provided, it won't be exported.\n  --tczyx / --no-tczyx          Expand data to make it (T, C, Z, Y, X)\n                                otherwise it's (T,) + Frame shape.  \\[default:\n                                no-tczyx]\n  --overwrite / --no-overwrite  Whether to overwrite the GEFF file if it\n                                already exists.  \\[default: no-overwrite]\n</code></pre>"},{"location":"command-line-tools/#convert-trackmate-xml","title":"convert-trackmate-xml","text":"<p>Convert a TrackMate XML file to a GEFF file.</p> <p>Usage:</p> <pre><code> convert-trackmate-xml [OPTIONS] XML_PATH GEFF_PATH\n</code></pre> <p>Options:</p> <pre><code>  XML_PATH                        The path to the TrackMate XML file\n                                  \\[required]\n  GEFF_PATH                       Path to save the output geff, including the\n                                  geff directory name (eg.\n                                  ~/folder/folder/data.zarr/tracks.geff)\n                                  \\[required]\n  --discard-filtered-spots / --no-discard-filtered-spots\n                                  True to discard the spots filtered out in\n                                  TrackMate, False otherwise.  \\[default: no-\n                                  discard-filtered-spots]\n  --discard-filtered-tracks / --no-discard-filtered-tracks\n                                  True to discard the tracks filtered out in\n                                  TrackMate, False otherwise.  \\[default: no-\n                                  discard-filtered-tracks]\n  --overwrite / --no-overwrite    Whether to overwrite the GEFF file if it\n                                  already exists.  \\[default: no-overwrite]\n  --zarr-format INTEGER           The version of zarr to write.  \\[default: 2]\n</code></pre>"},{"location":"command-line-tools/#info","title":"info","text":"<p>Display information about a GEFF file.</p> <p>Usage:</p> <pre><code> info [OPTIONS] INPUT_PATH\n</code></pre> <p>Options:</p> <pre><code>  INPUT_PATH  Path to the GEFF folder, e.g. data.zarr/tracks.geff  \\[required]\n</code></pre>"},{"location":"command-line-tools/#validate","title":"validate","text":"<p>Validate a GEFF file.</p> <p>Usage:</p> <pre><code> validate [OPTIONS] INPUT_PATH\n</code></pre> <p>Options:</p> <pre><code>  INPUT_PATH  Path to the GEFF folder, e.g. data.zarr/tracks.geff  \\[required]\n</code></pre>"},{"location":"command-line-tools/#running-command-line-tools","title":"Running command line tools","text":"<p>Without pip-installing <code>geff</code>, you can run the tools as  <pre><code>uvx geff -h # by uv\n# or \npipx geff -h # by pipx\n</code></pre></p>"},{"location":"command-line-tools/#running-command-with-a-developmental-build","title":"Running command with a developmental build","text":"<p>You can run the command line tool for your local build as </p> <pre><code>pip install -e .\ngeff -h\n</code></pre>"},{"location":"specification/","title":"Geff specification","text":"<p>The graph exchange file format is <code>zarr</code> based. A graph is stored in a zarr group, which can have any name. This allows storing multiple <code>geff</code> graphs inside the same zarr root directory. A <code>geff</code> group is identified by the presence of a <code>geff</code> key in the <code>.zattrs</code>. Other <code>geff</code> metadata is also stored in the <code>.zattrs</code> file of the <code>geff</code> group, nested under the <code>geff</code> key. The <code>geff</code> group must contain a <code>nodes</code> group and an <code>edges</code> group (albeit both can be empty). <code>geff</code> graphs have the option to provide properties for <code>nodes</code> and <code>edges</code>.</p> <p><code>geff</code> graphs have the option to provide time and spatial dimensions as special attributes. These attributes are specified in the <code>axes</code> section of the metadata, inspired by the OME-zarr <code>axes</code> specification. </p>"},{"location":"specification/#zarr-specification","title":"Zarr specification","text":"<p>Currently, <code>geff</code> supports zarr specifications 2 and 3. However, <code>geff</code> will default to writing specification 2 because graphs written to the zarr v3 spec will not be compatible with all applications. When zarr 3 is more fully adopted by other libraries and tools, we will move to a zarr spec 3 default.</p>"},{"location":"specification/#geff-metadata","title":"Geff metadata geff Required  geff_version Required  directed Required  axes  Any of  name Required  type  Any of  unit  Any of  min  Any of  max  Any of  node_props_metadata  Any of  Additional Properties  identifier Required  dtype Required  encoding  Any of  unit  Any of  name  Any of  description  Any of  edge_props_metadata  Any of  Additional Properties  sphere  Any of  ellipsoid  Any of  track_node_props  Any of  Additional Properties  related_objects  Any of  type Required  path Required  label_prop  Any of  affine  Any of  matrix Required  display_hints  Any of  display_horizontal Required  display_vertical Required  display_depth  Any of  display_time  Any of  extra","text":"GeffSchema Type: object root          geffgeff_metadataType: object <p>geff_metadata</p> root          geff geff_versionGeff VersionType: string <p>Geff version string following semantic versioning (MAJOR.MINOR.PATCH), optionally with .devN and/or +local parts (e.g., 0.3.1.dev6+g61d5f18). If not provided, the version will be set to the current geff package version.</p> Must match regular expression: <code>^\\d+\\.\\d+(?:\\.\\d+)?(?:\\.dev\\d+)?(?:\\+[a-zA-Z0-9]+)?</code> root          geff directedDirectedType: boolean <p>True if the graph is directed, otherwise False.</p> root          geff axesAxes Default: null <p>Optional list of Axis objects defining the axes of each node in the graph. Each object's <code>name</code> must be an existing attribute on the nodes. The optional <code>type</code> keymust be one of <code>space</code>, <code>time</code> or <code>channel</code>, though readers may not use this information. Each axis can additionally optionally define a <code>unit</code> key, which should match the validOME-Zarr units, and <code>min</code> and <code>max</code> keys to define the range of the axis.</p> <ul><li> Option 1 </li><li> Option 2 </li></ul> root          geff axes anyOf item 0Type: array No Additional ItemsEach item of this array must be: root          geff axes anyOf item 0 AxisAxisType: object root          geff axes anyOf item 0 Axis nameNameType: string root          geff axes anyOf item 0 Axis typeType Default: null <ul><li> Option 1 </li><li> Option 2 </li></ul> root          geff axes anyOf item 0 Axis type anyOf item 0Type: string root          geff axes anyOf item 0 Axis type anyOf item 1Type: null root          geff axes anyOf item 0 Axis unitUnit Default: null <ul><li> Option 1 </li><li> Option 2 </li></ul> root          geff axes anyOf item 0 Axis unit anyOf item 0Type: string root          geff axes anyOf item 0 Axis unit anyOf item 1Type: null root          geff axes anyOf item 0 Axis minMin Default: null <ul><li> Option 1 </li><li> Option 2 </li></ul> root          geff axes anyOf item 0 Axis min anyOf item 0Type: number root          geff axes anyOf item 0 Axis min anyOf item 1Type: null root          geff axes anyOf item 0 Axis maxMax Default: null <ul><li> Option 1 </li><li> Option 2 </li></ul> root          geff axes anyOf item 0 Axis max anyOf item 0Type: number root          geff axes anyOf item 0 Axis max anyOf item 1Type: null root          geff axes anyOf item 1Type: null root          geff node_props_metadataNode Props Metadata Default: null <p>Metadata for node properties. The keys are the property identifiers, and the values are PropMetadata objects describing the properties.</p> <ul><li> Option 1 </li><li> Option 2 </li></ul> root          geff node_props_metadata anyOf item 0Type: object <p>Each additional property must conform to the following schema</p> root          geff node_props_metadata anyOf item 0 PropMetadataPropMetadataType: object <p>Metadata describing a property in the geff graph.</p> root          geff node_props_metadata anyOf item 0 PropMetadata identifierIdentifierType: string <p>Identifier of the property. Must be unique within its own component subgroup (nodes or edges). Must be a non-empty string.</p> root          geff node_props_metadata anyOf item 0 PropMetadata dtypeDtypeType: string <p>Data type of the property. Must be a non-empty string. Examples of valid values: 'int', 'int16', 'float64', 'str', 'bool'. Examples of invalid values: 'integer', 'np.int16', 'number', 'string'.</p> root          geff node_props_metadata anyOf item 0 PropMetadata encodingEncoding Default: null <p>Optional encoding when the property is stored as a string. For example, but not limited to, 'utf-8' or 'ascii'.</p> <ul><li> Option 1 </li><li> Option 2 </li></ul> root          geff node_props_metadata anyOf item 0 PropMetadata encoding anyOf item 0Type: string root          geff node_props_metadata anyOf item 0 PropMetadata encoding anyOf item 1Type: null root          geff node_props_metadata anyOf item 0 PropMetadata unitUnit Default: null <p>Optional unit of the property.</p> <ul><li> Option 1 </li><li> Option 2 </li></ul> root          geff node_props_metadata anyOf item 0 PropMetadata unit anyOf item 0Type: string root          geff node_props_metadata anyOf item 0 PropMetadata unit anyOf item 1Type: null root          geff node_props_metadata anyOf item 0 PropMetadata nameName Default: null <p>Optional human friendly name of the property</p> <ul><li> Option 1 </li><li> Option 2 </li></ul> root          geff node_props_metadata anyOf item 0 PropMetadata name anyOf item 0Type: string root          geff node_props_metadata anyOf item 0 PropMetadata name anyOf item 1Type: null root          geff node_props_metadata anyOf item 0 PropMetadata descriptionDescription Default: null <p>Optional description of the property.</p> <ul><li> Option 1 </li><li> Option 2 </li></ul> root          geff node_props_metadata anyOf item 0 PropMetadata description anyOf item 0Type: string root          geff node_props_metadata anyOf item 0 PropMetadata description anyOf item 1Type: null root          geff node_props_metadata anyOf item 1Type: null root          geff edge_props_metadataEdge Props Metadata Default: null <p>Metadata for edge properties. The keys are the property identifiers, and the values are PropMetadata objects describing the properties.</p> <ul><li> Option 1 </li><li> Option 2 </li></ul> root          geff edge_props_metadata anyOf item 0Type: object <p>Each additional property must conform to the following schema</p> root          geff edge_props_metadata anyOf item 0 PropMetadataPropMetadataType: object <p>Metadata describing a property in the geff graph.</p> Same definition as PropMetadata root          geff edge_props_metadata anyOf item 1Type: null root          geff sphereNode property: Detections as spheres Default: null <pre><code>        Name of the optional `sphere` property.\n\n        A sphere is defined by\n        - a center point, already given by the `space` type properties\n        - a radius scalar, stored in this property\n</code></pre> <ul><li> Option 1 </li><li> Option 2 </li></ul> root          geff sphere anyOf item 0Type: string root          geff sphere anyOf item 1Type: null root          geff ellipsoidNode property: Detections as ellipsoids Default: null <pre><code>        Name of the `ellipsoid` property.\n\n        An ellipsoid is assumed to be in the same coordinate system as the `space` type\n        properties.\n\n        It is defined by\n        - a center point :math:`c`, already given by the `space` type properties\n        - a covariance matrix :math:`\\Sigma`, symmetric and positive-definite, stored in this\n          property as a `2x2`/`3x3` array.\n\n        To plot the ellipsoid:\n        - Compute the eigendecomposition of the covariance matrix\n        :math:`\\Sigma = Q \\Lambda Q^{\\top}`\n        - Sample points :math:`z` on the unit sphere\n        - Transform the points to the ellipsoid by\n        :math:`x = c + Q \\Lambda^{(1/2)} z`.\n</code></pre> <ul><li> Option 1 </li><li> Option 2 </li></ul> root          geff ellipsoid anyOf item 0Type: string root          geff ellipsoid anyOf item 1Type: null root          geff track_node_propsTrack Node Props Default: null <p>Node properties denoting tracklet and/or lineage IDs. A tracklet is defined as a simple path of connected nodes where the initiating node has any incoming degree and outgoing degree at most 1,and the terminating node has incoming degree at most 1 and any outgoing degree, and other nodes along the path have in/out degree of 1. Each tracklet must contain the maximal set of connected nodes that match this definition - no sub-tracklets. A lineage is defined as a weakly connected component on the graph. The dictionary can store one or both of 'tracklet' or 'lineage' keys.</p> <ul><li> Option 1 </li><li> Option 2 </li></ul> root          geff track_node_props anyOf item 0Type: object <p>Each additional property must conform to the following schema</p> root          geff track_node_props anyOf item 0 additionalPropertiesType: string root          geff track_node_props anyOf item 1Type: null root          geff related_objectsRelated Objects Default: null <p>A list of dictionaries of related objects such as labels or images. Each dictionary must contain 'type', 'path', and optionally 'labelprop' properties. The 'type' represents the data type. 'labels' and 'image' should be used for label and image objects, respectively. Other types are also allowed, The 'path' should be relative to the geff zarr-attributes file. It is strongly recommended all related objects are stored as siblings of the geff group within the top-level zarr group. The 'labelprop' is only valid for type 'labels' and specifies the node property that will be used to identify the labels in the related object. </p> <ul><li> Option 1 </li><li> Option 2 </li></ul> root          geff related_objects anyOf item 0Type: array No Additional ItemsEach item of this array must be: root          geff related_objects anyOf item 0 RelatedObjectRelatedObjectType: object root          geff related_objects anyOf item 0 RelatedObject typeTypeType: string <p>Type of the related object. 'labels' for label objects, 'image' for image objects. Other types are also allowed, but may not be recognized by reader applications. </p> root          geff related_objects anyOf item 0 RelatedObject pathPathType: string <p>Path of the related object within the zarr group, relative to the geff zarr-attributes file. It is strongly recommended all related objects are stored as siblings of the geff group within the top-level zarr group.</p> root          geff related_objects anyOf item 0 RelatedObject label_propLabel Prop Default: null <p>Property name for label objects. This is the node property that will be used to identify the labels in the related object. This is only valid for type 'labels'.</p> <ul><li> Option 1 </li><li> Option 2 </li></ul> root          geff related_objects anyOf item 0 RelatedObject label_prop anyOf item 0Type: string root          geff related_objects anyOf item 0 RelatedObject label_prop anyOf item 1Type: null root          geff related_objects anyOf item 1Type: null root          geff affine Default: null <p>Affine transformation matrix to transform the graph coordinates to the physical coordinates. The matrix must have the same number of dimensions as the number of axes in the graph.</p> <ul><li> Affine </li><li> Option 2 </li></ul> root          geff affine anyOf AffineAffineType: object <p>Affine transformation matrix following scipy conventions.</p> <p>Internally stores transformations as homogeneous coordinate matrices (N+1, N+1). The transformation matrix follows scipy.ndimage.affine_transform convention where the matrix maps output coordinates to input coordinates (inverse/pull transformation).</p> <p>For a point pout in output space, the corresponding input point pin is computed as: pinhomo = matrix @ pouthomo where pouthomo = [pout; 1] and pin = pinhomo[:-1]</p> <p>Attributes:     matrix (np.ndarray) : square, homogeneous transformation matrix (ndim+1, ndim+1)</p> root          geff affine anyOf Affine matrixMatrixType: array of array <p>Homogeneous transformation matrix (ndim+1, ndim+1)</p> No Additional ItemsEach item of this array must be: root          geff affine anyOf Affine matrix matrix itemsType: array of number No Additional ItemsEach item of this array must be: root          geff affine anyOf Affine matrix matrix items matrix items itemsType: number root          geff affine anyOf item 1Type: null root          geff display_hints Default: null <p>Metadata indicating how spatiotemporal axes are displayed by a viewer</p> <ul><li> DisplayHint </li><li> Option 2 </li></ul> root          geff display_hints anyOf DisplayHintDisplayHintType: object <p>Metadata indicating how spatiotemporal axes are displayed by a viewer</p> root          geff display_hints anyOf DisplayHint display_horizontalDisplay HorizontalType: string <p>Which spatial axis to use for horizontal display</p> root          geff display_hints anyOf DisplayHint display_verticalDisplay VerticalType: string <p>Which spatial axis to use for vertical display</p> root          geff display_hints anyOf DisplayHint display_depthDisplay Depth Default: null <p>Optional, which spatial axis to use for depth display</p> <ul><li> Option 1 </li><li> Option 2 </li></ul> root          geff display_hints anyOf DisplayHint display_depth anyOf item 0Type: string root          geff display_hints anyOf DisplayHint display_depth anyOf item 1Type: null root          geff display_hints anyOf DisplayHint display_timeDisplay Time Default: null <p>Optional, which temporal axis to use for time</p> <ul><li> Option 1 </li><li> Option 2 </li></ul> root          geff display_hints anyOf DisplayHint display_time anyOf item 0Type: string root          geff display_hints anyOf DisplayHint display_time anyOf item 1Type: null root          geff display_hints anyOf item 1Type: null root          geff extraExtraType: object <p>Extra metadata that is not part of the schema</p> <p>Note</p> <p>The axes dictionary is modeled after the OME-zarr specifications and is used to identify spatio-temporal properties on the graph nodes. If the same names are used in the axes metadata of the related image or segmentation data, applications can use this information to align graph node locations with image data. </p>"},{"location":"specification/#geff.valid_values.VALID_AXIS_TYPES","title":"geff.valid_values.VALID_AXIS_TYPES  <code>module-attribute</code>","text":"<pre><code>VALID_AXIS_TYPES = ['space', 'time', 'channel']\n</code></pre>"},{"location":"specification/#geff.valid_values.VALID_SPACE_UNITS","title":"geff.valid_values.VALID_SPACE_UNITS  <code>module-attribute</code>","text":"<pre><code>VALID_SPACE_UNITS = [\n    None,\n    \"angstrom\",\n    \"attometer\",\n    \"centimeter\",\n    \"decimeter\",\n    \"exameter\",\n    \"femtometer\",\n    \"foot\",\n    \"gigameter\",\n    \"hectometer\",\n    \"inch\",\n    \"kilometer\",\n    \"megameter\",\n    \"meter\",\n    \"micrometer\",\n    \"mile\",\n    \"millimeter\",\n    \"nanometer\",\n    \"parsec\",\n    \"petameter\",\n    \"picometer\",\n    \"terameter\",\n    \"yard\",\n    \"yoctometer\",\n    \"yottameter\",\n    \"zeptometer\",\n    \"zettameter\",\n]\n</code></pre>"},{"location":"specification/#geff.valid_values.VALID_TIME_UNITS","title":"geff.valid_values.VALID_TIME_UNITS  <code>module-attribute</code>","text":"<pre><code>VALID_TIME_UNITS = [\n    None,\n    \"attosecond\",\n    \"centisecond\",\n    \"day\",\n    \"decisecond\",\n    \"exasecond\",\n    \"femtosecond\",\n    \"gigasecond\",\n    \"hectosecond\",\n    \"hour\",\n    \"kilosecond\",\n    \"megasecond\",\n    \"microsecond\",\n    \"millisecond\",\n    \"minute\",\n    \"nanosecond\",\n    \"petasecond\",\n    \"picosecond\",\n    \"second\",\n    \"terasecond\",\n    \"yoctosecond\",\n    \"yottasecond\",\n    \"zeptosecond\",\n    \"zettasecond\",\n]\n</code></pre>"},{"location":"specification/#affine-transformations","title":"Affine transformations","text":"<p>The optional <code>affine</code> field allows specifying a global affine transformation that maps the graph coordinates stored in the node properties to a physical coordinate system. The value matrix is stored as a <code>(N + 1) \u00d7 (N + 1)</code> homogeneous matrix following the <code>scipy.ndimage.affine_transform</code> convention, where N equals the number of spatio-temporal axes declared in <code>axes</code>.</p>"},{"location":"specification/#extra-attributes","title":"Extra attributes","text":"<p>The optional <code>extra</code> object is a free-form dictionary that can hold any additional, application-specific metadata that is not covered by the core geff schema. Users may place arbitrary keys and values inside <code>extra</code> without fear of clashing with future reserved fields. Although the core <code>geff</code> reader makes these attributes available, their meaning and use are left entirely to downstream applications. </p>"},{"location":"specification/#the-nodes-group","title":"The <code>nodes</code> group","text":"<p>The nodes group will contain an <code>ids</code> array and optionally a <code>props</code> group. </p>"},{"location":"specification/#the-ids-array","title":"The <code>ids</code> array","text":"<p>The <code>nodes\\ids</code> array is a 1D array of node IDs of length <code>N</code> &gt;= 0, where <code>N</code> is the number of nodes in the graph. Node ids must be unique. Node IDs can have any type supported by zarr (except floats), but we recommend integer dtypes. For large graphs, <code>uint64</code> might be necessary to provide enough range for every node to have a unique ID. In the minimal case of an empty graph, the <code>ids</code> array will be present but empty. </p>"},{"location":"specification/#the-props-group-and-node-property-groups","title":"The <code>props</code> group and <code>node property</code> groups","text":"<p>The <code>nodes\\props</code> group is optional and will contain one or more <code>node property</code> groups, each with a <code>values</code> array and an optional <code>missing</code> array.</p> <ul> <li><code>values</code> arrays can be any zarr supported dtype, and can be N-dimensional. The first dimension of the <code>values</code> array must have the same length as the node <code>ids</code> array, such that each row of the property <code>values</code> array stores the property for the node at that index in the ids array.</li> <li> <p>The <code>missing</code> array is an optional, a one dimensional boolean array to support properties that are not present on all nodes. A <code>1</code> at an index in the <code>missing</code> array indicates that the <code>value</code> of that property for the node at that index is None, and the value in the <code>values</code> array at that index should be ignored. If the <code>missing</code> array is not present, that means that all nodes have values for the property.</p> </li> <li> <p>Geff provides special support for spatio-temporal properties, although they are not required. When <code>axes</code> are specified in the <code>geff</code> metadata, each axis name identifies a spatio-temporal property. Spatio-temporal properties are not allowed to have missing arrays. Otherwise, they are identical to other properties from a storage specification perspective.</p> </li> <li> <p>The <code>seg_id</code> property is an optional, special node property that stores the segmenatation label for each node. The <code>seg_id</code> values do not need to be unique, in case labels are repeated between time points. If the <code>seg_id</code> property is not present, it is assumed that the graph is not associated with a segmentation. </p> </li> <li> <p>Geff provides special support for predefined shape properties, although they are not required. These currently include: <code>sphere</code>, <code>ellipsoid</code>. Values can be marked as <code>missing</code>, and a geff graph may contain multiple different shape properties. Units of shapes are assumed to be the same as the units on the spatial axes. Otherwise, shape properties are identical to other properties from a storage specification perspective.</p> <ul> <li><code>sphere</code>: Hypersphere in n spatial dimensions, defined by a scalar radius.</li> <li><code>ellipsoid</code>: Defined by a symmetric positive-definite covariance matrix, whose dimensionality is assumed to match the spatial axes.</li> </ul> </li> </ul> <p>Note</p> <p>When writing a graph with missing properties to the geff format, you must fill in a dummy value in the <code>values</code> array for the nodes that are missing the property, in order to keep the indices aligned with the node ids. </p>"},{"location":"specification/#the-edges-group","title":"The <code>edges</code> group","text":"<p>Similar to the <code>nodes</code> group, the <code>edges</code> group will contain an <code>ids</code> array and an optional <code>props</code> group.</p>"},{"location":"specification/#the-ids-array_1","title":"The <code>ids</code> array","text":"<p>The <code>edges\\ids</code> array is a 2D array with the same dtype as the <code>nodes\\ids</code> array. It has shape <code>(E, 2)</code>, where <code>E</code> is the number of edges in the graph. If there are no edges in the graph, the edge group and <code>ids</code> array must be present with shape <code>(0, 2)</code>.  All elements in the <code>edges\\ids</code> array must also be present in the <code>nodes\\ids</code> array, and the data types of the two id arrays must match. Each row represents an edge between two nodes. For directed graphs, the first column is the source nodes and the second column holds the target nodes. For undirected graphs, the order is arbitrary. Edges should be unique (no multiple edges between the same two nodes) and edges from a node to itself are not supported.</p>"},{"location":"specification/#the-props-group-and-edge-property-groups","title":"The <code>props</code> group and <code>edge property</code> groups","text":"<p>The <code>edges\\props</code> group will contain zero or more <code>edge property</code> groups, each with a <code>values</code> array and an optional <code>missing</code> array.</p> <ul> <li><code>values</code> arrays can be any zarr supported dtype, and can be N-dimensional. The first dimension of the <code>values</code> array must have the same length as the <code>edges\\ids</code> array, such that each row of the property <code>values</code> array stores the property for the edge at that index in the ids array.</li> <li>The <code>missing</code> array is an optional, a one dimensional boolean array to support properties that are not present on all edges. A <code>1</code> at an index in the <code>missing</code> array indicates that the <code>value</code> of that property for the edge at that index is missing, and the value in the <code>values</code> array at that index should be ignored. If the <code>missing</code> array is not present, that means that all edges have values for the property.</li> </ul> <p>The <code>edges/props</code> is optional. If you do not have any edge properties, the <code>edges\\props</code> can be absent. </p>"},{"location":"specification/#example-file-structure-and-metadata","title":"Example file structure and metadata","text":"<p>Here is a schematic of the expected file structure. <pre><code>/path/to.zarr\n    /tracking_graph\n        .zattrs  # graph metadata with `geff_version`\n        nodes/\n            ids  # shape: (N,)  dtype: uint64\n            props/\n                t/\n                    values # shape: (N,) dtype: uint16\n                z/\n                    values # shape: (N,) dtype: float32\n                y/\n                    values # shape: (N,) dtype: float32\n                x/\n                    values # shape: (N,) dtype: float32\n                radius/\n                    values # shape: (N,) dtype: int | float\n                    missing # shape: (N,) dtype: bool\n                covariance3d/\n                    values # shape: (N, 3, 3) dtype: float\n                    missing # shape: (N,) dtype: bool\n                color/\n                    values # shape: (N, 4) dtype: float16\n                    missing # shape: (N,) dtype: bool\n        edges/\n            ids  # shape: (E, 2) dtype: uint64\n            props/\n                distance/\n                    values # shape: (E,) dtype: float16\n                score/\n                    values # shape: (E,) dtype: float16\n                    missing # shape: (E,) dtype: bool\n    # optional:\n    /segmentation \n\n    # unspecified, but totally okay:\n    /raw \n</code></pre> This is a geff metadata zattrs file that matches the above example structure. <pre><code>// /path/to.zarr/tracking_graph/.zattrs\n{   \n    \"geff\": {\n        \"directed\": true,\n        \"geff_version\": \"0.1.3.dev4+gd5d1132.d20250616\",\n        // axes are optional\n        \"axes\": [\n            {\"name\": \"t\", \"type\": \"time\", \"unit\": \"seconds\", \"min\": 0, \"max\": 125},\n            {\"name\": \"z\", \"type\": \"space\", \"unit\": \"micrometers\", \"min\": 1523.36, \"max\": 4398.1},\n            {\"name\": \"y\", \"type\": \"space\", \"unit\": \"micrometers\", \"min\": 81.667, \"max\": 1877.7},\n            {\"name\": \"x\", \"type\": \"space\", \"unit\": \"micrometers\", \"min\": 764.42, \"max\": 2152.3}\n        ],\n        // predefined node attributes for storing detections as spheres or ellipsoids\n        \"sphere\": \"radius\", // optional\n        \"ellipsoid\": \"covariance3d\", // optional\n        \"display_hints\": {\n            \"display_horizontal\": \"x\",\n            \"display_vertical\": \"y\",\n            \"display_depth\": \"z\",\n            \"display_time\": \"t\"\n        },\n        // node attributes corresponding to tracklet and/or lineage IDs\n        \"track_node_props\": {\n            \"lineage\": \"ultrack_lineage_id\",\n            \"tracklet\": \"ultrack_id\"\n        },\n        \"related_objects\": [\n            {\n                \"type\":\"labels\", \"path\":\"../segmentation/\", \"label_prop\": \"seg_id\"\n            },\n            {\n                \"type\":\"image\", \"path\":\"../raw/\"\n            }\n        ],\n        // optional coordinate transformation is defined as homogeneous coordinates\n        // It is expected to be a (D+1)x(D+1) matrix where D is the number of axes\n        \"affine\": [\n            [1, 0, 0, 0, 0],\n            [0, 1, 0, 0, 0],\n            [0, 0, 1, 0, 0],\n            [0, 0, 0, 1, 0],\n            [0, 0, 0, 0, 1]\n        ],\n        // custom other things must be placed **inside** the extra attribute\n        \"extra\": {\n            // ...\n        }\n    }\n}\n</code></pre></p>"},{"location":"what-is-geff/","title":"What is geff?","text":"<p><code>geff</code> is a graph exchange file format that seeks to fulfill the following needs:</p> <ul> <li>Provide a storage/exchange format for graphs and optional segmentation</li> <li>Provide a common API with reference implementations for use in other projects</li> </ul>"},{"location":"what-is-geff/#design-decisions-and-assumptions","title":"Design Decisions and Assumptions","text":"<ul> <li>Raw image data is not included in the <code>geff</code> spec. However, to keep nodes linked to segmentation labels, support for specifying the seg_id of each node in a standard way, along with the path to the segmentation, are included in the <code>spec</code>.</li> <li>Since <code>geff</code> is an exchange format, we do not provide support for searching or filtering.</li> <li>We do not provide support for editing or changing the graph on the fly.</li> <li>In order to support efficient reading/writing, we assume the graph can fit into memory.</li> </ul>"}]}